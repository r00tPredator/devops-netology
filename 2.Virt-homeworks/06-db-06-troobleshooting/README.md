# Домашнее задание к занятию "6.6. Troubleshooting"

## Задача 1

Перед выполнением задания ознакомьтесь с документацией по [администрированию MongoDB](https://docs.mongodb.com/manual/administration/).

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её 
нужно прервать. 

Вы как инженер поддержки решили произвести данную операцию:
- напишите список операций, которые вы будете производить для остановки запроса пользователя
- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

### Ответ 1:
#### Остановки запроса пользователя

Пользователи всегда могут запустить db.currentOp( { "$ownOps": true } ), чтобы просмотреть свои собственные операции.<br />

Следующий пример возвращает информацию обо всех активных операциях для базы данных db1, которые выполнялись более 3 минут:
```json
db.currentOp({ "active" : true, "secs_running" : { "$gt" : 180 },"ns" : /^db1\./})

db.currentOp(
   {
     "active" : true,
     "secs_running" : { "$gt" : 180 },
     "ns" : /^db1\./
   }
)
```

Найдем эту операцию и завершим командой:<br />
   db.killOp(<opid of the query to kill>)


#### Решения проблемы с долгими (зависающими) запросами в MongoDB
Утилита [mongostat](https://docs.mongodb.com/database-tools/mongostat/) предоставляет краткий обзор состояния запущенного в данный момент экземпляра mongod.<br />
Метод [maxTimeMS()](https://docs.mongodb.com/manual/tutorial/terminate-running-operations/#maxtimems) устанавливает ограничение по времени для операции. Когда операция достигает указанного ограничения по времени <br />
Профилировщик базы данных [profiler Database](https://docs.mongodb.com/manual/tutorial/manage-the-database-profiler/) собирает подробную информацию о командах базы данных, выполняемых для запущенного экземпляра mongod. <br />
Отловить медленные запросы можно через [$explain](https://docs.mongodb.com/manual/reference/explain-results/#executionstats)<br />
Оптимизировать: постороить/перестроить, добавить/удалить индексы, настроить шардинг и т.д.

## Задача 2

Перед выполнением задания познакомьтесь с документацией по [Redis latency troobleshooting](https://redis.io/topics/latency).

Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. 
Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и
увеличивается пропорционально количеству реплик сервиса. 

При масштабировании сервиса до N реплик вы увидели, что:
- сначала рост отношения записанных значений к истекшим
- Redis блокирует операции записи

### Ответ 2:
- Как вы думаете, в чем может быть проблема?
```
Следую из документации:
Возможно нехватка оперативной памяти.
"Если ваша проблема с задержкой связана с заменой памяти Redis на диске, вам необходимо снизить нагрузку на память в вашей системе, либо добавив больше оперативной памяти, если Redis использует больше памяти, чем доступно, либо избегая запуска других процессов с нехваткой памяти в той же системе."
Redis в основном однопоточный, если уже что-то пишется на остальные запросы может идти блокировка.
```
 
## Задача 3

Перед выполнением задания познакомьтесь с документацией по [Common Mysql errors](https://dev.mysql.com/doc/refman/8.0/en/common-errors.html).

Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы,
пользователи начали жаловаться на ошибки вида:
```python
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
```
### Ответ 3:
```md
- Как вы думаете, почему это начало происходить и как локализовать проблему?
В посторах интернета предполагают, что или кто-то рестатартит сервер, или кто-то получил привилегии и рестартит сервис.

В Документации сказано, что существует три вероятные причины появления этого сообщения об ошибке.

Обычно это указывает на проблемы с сетевым подключением, и вам следует проверить состояние вашей сети, если эта ошибка возникает часто. Если сообщение об ошибке содержит “во время запроса”, вероятно, это тот случай, с которым вы столкнулись.

Иногда форма “во время запроса” возникает, когда миллионы строк отправляются как часть одного или нескольких запросов. Если вы знаете, что это происходит, вам следует попробовать увеличить [net_read_timeout](https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_net_read_timeout) с значения по умолчанию 30 секунд до 60 секунд или дольше, достаточного для завершения передачи данных.

Реже это может произойти, когда клиент пытается установить первоначальное соединение с сервером. В этом случае, если ваше значение [connect_timeout](https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_connect_timeout) установлено всего на несколько секунд, вы можете решить проблему, увеличив его до десяти секунд, возможно, больше, если у вас очень большое расстояние или медленное соединение. Вы можете определить, сталкиваетесь ли вы с этой более необычной причиной, используя SHOW GLOBAL STATUS LIKE 'Aborted_connects'. Он увеличивается на единицу при каждой первоначальной попытке подключения, которую прерывает сервер. Вы можете увидеть “чтение пакета авторизации” как часть сообщения об ошибке; если да, то это также говорит о том, что это именно то решение, которое вам нужно.

Если причина не является ни одной из только что описанных, возможно, у вас возникла проблема со значениями больших двоичных объектов [BLOB] (https://dev.mysql.com/doc/refman/8.0/en/blob.html), которые больше [max_allowed_packet](https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_max_allowed_packet), что может вызвать эту ошибку у некоторых клиентов. Иногда вы можете увидеть ошибку [ER_NET_PACKET_TOO_LARGE](https://dev.mysql.com/doc/mysql-errors/8.0/en/server-error-reference.html#error_er_net_packet_too_large), и это подтверждает, что вам необходимо увеличить [max_allowed_packet](https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_max_allowed_packet).
Если ошибка пропадёт, возвращая по одному в исходное состояние, так мы можем локализовать проблему.

- Какие пути решения данной проблемы вы можете предложить?
max_connections= может помочь, если предпологается, что сервер рестатартится.

В остальных случаях. Поправить все перечисленные параметры:

Увеличить на сервере MySQL wait_timeout, max_allowed_packet, net_write_timeout и net_read_timeout
В SQLAlchemy уменьшить pool_recycle, сделать меньше wait_timeout

Возможно достаточно будет оптимизировать запросы. Их можно найти включив slow_query_log и настроив параметр long_query_time на значение близкое к net_write_timeout и net_read_timeout.

```

## Задача 4

Перед выполнением задания ознакомтесь со статьей [Common PostgreSQL errors](https://www.percona.com/blog/2020/06/05/10-common-postgresql-errors/) из блога Percona.

Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с 
большим объемом данных лучше, чем MySQL.

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

`postmaster invoked oom-killer`

### Ответ 4:

- Как вы думаете, что происходит?
Когда памяти остается недостаточно, oom-killer и убивает процесс PostgreSQL. 

- Как бы вы решили данную проблему?
Некоторые люди отключают этот процесс, но это не рекомендуется. Необходимо проверить настройки памяти в соответствии с нашим оборудованием.

---

### Как cдавать задание

Выполненное домашнее задание пришлите ссылкой на .md-файл в вашем репозитории.

---
